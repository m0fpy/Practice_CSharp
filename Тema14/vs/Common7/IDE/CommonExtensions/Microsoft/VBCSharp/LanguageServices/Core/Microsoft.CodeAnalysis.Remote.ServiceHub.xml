<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Microsoft.CodeAnalysis.Remote.ServiceHub</name>
    </assembly>
    <members>
        <member name="T:Microsoft.CodeAnalysis.Remote.AssetProvider">
            <summary>
            This service provide a way to get roslyn objects from checksum
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Remote.AssetProvider.#ctor(Microsoft.CodeAnalysis.Checksum,Microsoft.CodeAnalysis.Remote.SolutionAssetCache,Microsoft.CodeAnalysis.Remote.IAssetSource,Microsoft.CodeAnalysis.Serialization.ISerializerService)">
            <summary>
            This service provide a way to get roslyn objects from checksum
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Remote.IAssetSource">
            <summary>
            Provides assets given their checksums.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Remote.Host.GlobalServiceBroker">
            <summary>
            Hacky way to expose a <see cref="T:Microsoft.ServiceHub.Framework.IServiceBroker"/> to workspace services that expect there to be a global
            singleton (like in visual studio).  Effectively the first service that gets called into will record its
            broker here for these services to use.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Remote.Diagnostics.RemoteAnalyzerAssemblyLoader">
            <summary>
            For analyzers shipped in Roslyn, different set of assemblies might be used when running
            in-proc and OOP e.g. in-proc (VS) running on desktop clr and OOP running on ServiceHub .Net6
            host. We need to make sure to use the ones from the same location as the remote.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Remote.Diagnostics.RemoteAnalyzerAssemblyLoaderService">
            <summary>
            Customizes the path where to store shadow-copies of analyzer assemblies.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Remote.Diagnostics.DiagnosticComputer.s_compilationWithAnalyzersCache">
            <summary>
            Cache of <see cref="T:Microsoft.CodeAnalysis.Diagnostics.CompilationWithAnalyzers"/> and a map from analyzer IDs to <see cref="T:Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer"/>s
            for all analyzers for the last project to be analyzed.
            The <see cref="T:Microsoft.CodeAnalysis.Diagnostics.CompilationWithAnalyzers"/> instance is shared between all the following document analyses modes for the project:
             1. Span-based analysis for active document (lightbulb)
             2. Background analysis for active and open documents.
             
            NOTE: We do not re-use this cache for project analysis as it leads to significant memory increase in the OOP process.
            Additionally, we only store the cache entry for the last project to be analyzed instead of maintaining a CWT keyed off
            each project in the solution, as the CWT does not seem to drop entries until ForceGC happens, leading to significant memory
            pressure when there are large number of open documents across different projects to be analyzed by background analysis.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Remote.Diagnostics.DiagnosticComputer.s_highPriorityComputeTasks">
            <summary>
            Set of high priority diagnostic computation tasks which are currently executing.
            Any new high priority diagnostic request is added to this set before the core diagnostics
            compute call is performed, and removed from this list after the computation finishes.
            Any new normal priority diagnostic request first waits for all the high priority tasks in this set
            to complete, and moves ahead only after this list becomes empty.
            </summary>
            <remarks>
            Read/write access to this field is guarded by <see cref="F:Microsoft.CodeAnalysis.Remote.Diagnostics.DiagnosticComputer.s_gate"/>.
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Remote.Diagnostics.DiagnosticComputer.s_normalPriorityCancellationTokenSources">
            <summary>
            Set of cancellation token sources for normal priority diagnostic computation tasks which are currently executing.
            For any new normal priority diagnostic request, a new cancellation token source is created and added to this set
            before the core diagnostics compute call is performed, and removed from this set after the computation finishes.
            Any new high priority diagnostic request first fires cancellation on all the cancellation token sources in this set
            to avoid resource contention between normal and high priority requests.
            Canceled normal priority diagnostic requests are re-attempted from scratch after all the high priority requests complete.
            </summary>
            <remarks>
            Read/write access to this field is guarded by <see cref="F:Microsoft.CodeAnalysis.Remote.Diagnostics.DiagnosticComputer.s_gate"/>.
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Remote.Diagnostics.DiagnosticComputer.s_gate">
            <summary>
            Static gate controlling access to following static fields:
            - <see cref="F:Microsoft.CodeAnalysis.Remote.Diagnostics.DiagnosticComputer.s_compilationWithAnalyzersCache"/>
            - <see cref="F:Microsoft.CodeAnalysis.Remote.Diagnostics.DiagnosticComputer.s_highPriorityComputeTasks"/>
            - <see cref="F:Microsoft.CodeAnalysis.Remote.Diagnostics.DiagnosticComputer.s_normalPriorityCancellationTokenSources"/>
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Remote.Diagnostics.DiagnosticComputer._solutionChecksum">
            <summary>
            Solution checksum for the diagnostic request.
            We use this checksum and the <see cref="T:Microsoft.CodeAnalysis.ProjectId"/> of the diagnostic request as the key
            to the <see cref="F:Microsoft.CodeAnalysis.Remote.Diagnostics.DiagnosticComputer.s_compilationWithAnalyzersCache"/>.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Remote.Diagnostics.PerformanceQueue">
            <summary>
            This queue hold onto raw performance data. this type itself is not thread safe. the one who uses this type
            should take care of that.
            </summary>
            <threadsafety static="false" instance="false"/>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Remote.Diagnostics.PerformanceQueue.Snapshot._performanceMap">
            <summary>
            Raw performance data. 
            Keyed by analyzer unique number got from AnalyzerNumberAssigner.
            Value is delta (TimeSpan - minSpan) among span in this snapshot
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Remote.Diagnostics.PerformanceQueue.AnalyzerNumberAssigner">
            <summary>
            Assign unique number to diagnostic analyzers
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Remote.Diagnostics.PerformanceTrackerService">
            <summary>
            Track diagnostic performance 
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Remote.RemoteDocumentDifferenceService">
            <summary>
            Provide document difference service specific to remote workspace's behavior.
            
            Default <see cref="T:Microsoft.CodeAnalysis.SolutionCrawler.AbstractDocumentDifferenceService"/> is optimized for typing case in editor where we have events
            for each typing. But in remote workspace, we aggregate changes and update solution in bulk and we don't have concept
            of active file making default implementation unsuitable. Functionally, default one is still correct, but it often
            time makes us to do more than we need. Basically, it always says this project has semantic change which can cause
            a lot of re-analysis.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Remote.RemoteHostTestData">
            <summary>
            Test hook used to pass test data to remote services.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Remote.RemoteWorkspace">
            <summary>
            Workspace created by the remote host that mirrors the corresponding client workspace.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Remote.RemoteWorkspace._gate">
            <summary>
            Guards updates to all mutable state in this workspace.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Remote.RemoteWorkspace._currentRemoteWorkspaceVersion">
            <summary>
            Used to make sure we never move remote workspace backward. this version is the WorkspaceVersion of primary
            solution in client (VS) we are currently caching.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Remote.RemoteWorkspace.UpdatePrimaryBranchSolutionAsync(Microsoft.CodeAnalysis.Remote.AssetProvider,Microsoft.CodeAnalysis.Checksum,System.Int32,System.Threading.CancellationToken)">
            <summary>
            Syncs over the solution corresponding to <paramref name="solutionChecksum"/> and sets it as the current
            solution for <see langword="this"/> workspace.  This will also end up updating <see
            cref="F:Microsoft.CodeAnalysis.Remote.RemoteWorkspace._lastRequestedAnyBranchSolution"/> and <see cref="F:Microsoft.CodeAnalysis.Remote.RemoteWorkspace._lastRequestedPrimaryBranchSolution"/>, allowing
            them to be pre-populated for feature requests that come in soon after this call completes.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Remote.RemoteWorkspace.RunWithSolutionAsync``1(Microsoft.CodeAnalysis.Remote.AssetProvider,Microsoft.CodeAnalysis.Checksum,System.Func{Microsoft.CodeAnalysis.Solution,System.Threading.Tasks.ValueTask{``0}},System.Threading.CancellationToken)">
            <summary>
            Given an appropriate <paramref name="solutionChecksum"/>, gets or computes the corresponding <see
            cref="T:Microsoft.CodeAnalysis.Solution"/> snapshot for it, and then invokes <paramref name="implementation"/> with that snapshot.  That
            snapshot and the result of <paramref name="implementation"/> are then returned from this method.  Note: the
            solution returned is only for legacy cases where we expose OOP to 2nd party clients who expect to be able to
            call through <see cref="M:Microsoft.CodeAnalysis.Remote.RemoteWorkspaceManager.GetSolutionAsync(Microsoft.ServiceHub.Framework.ServiceBrokerClient,Microsoft.CodeAnalysis.Checksum,System.Threading.CancellationToken)"/> and who expose that statically to
            themselves.
            <para>
            During the life of the call to <paramref name="implementation"/> the solution corresponding to <paramref
            name="solutionChecksum"/> will be kept alive and returned to any other concurrent calls to this method with
            the same <paramref name="solutionChecksum"/>.
            </para>
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Remote.RemoteWorkspace.ComputeDisconnectedSolutionAsync(Microsoft.CodeAnalysis.Remote.AssetProvider,Microsoft.CodeAnalysis.Checksum,System.Threading.CancellationToken)">
            <summary>
            Create an appropriate <see cref="T:Microsoft.CodeAnalysis.Solution"/> instance corresponding to the <paramref
            name="solutionChecksum"/> passed in.  Note: this method changes no Workspace state and exists purely to
            compute the corresponding solution.  Updating of our caches, or storing this solution as the <see
            cref="P:Microsoft.CodeAnalysis.Workspace.CurrentSolution"/> of this <see cref="T:Microsoft.CodeAnalysis.Remote.RemoteWorkspace"/> is the responsibility of any
            callers.
            <para>
            The term 'disconnected' is used to mean that this solution is not assigned to be the current solution of
            this <see cref="T:Microsoft.CodeAnalysis.Remote.RemoteWorkspace"/>.  It is effectively a fork of that instead.
            </para>
            <para>
            This method will either create the new solution from scratch if it has to.  Or it will attempt to create a
            fork off of <see cref="P:Microsoft.CodeAnalysis.Workspace.CurrentSolution"/> if possible.  The latter is almost always what will
            happen (once the first sync completes) as most calls to the remote workspace are using a solution snapshot
            very close to the primary one, and so can share almost all state with that.
            </para>
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Remote.RemoteWorkspace.TryUpdateWorkspaceCurrentSolutionAsync(System.Int32,Microsoft.CodeAnalysis.Solution,System.Threading.CancellationToken)">
            <summary>
            Attempts to update this workspace with the given <paramref name="newSolution"/>.  If this succeeds, <see
            langword="true"/> will be returned in the tuple result as well as the actual solution that the workspace is
            updated to point at.  If we cannot update this workspace, then <see langword="false"/> will be returned,
            along with the solution passed in.  The only time the solution can not be updated is if it would move <see
            cref="F:Microsoft.CodeAnalysis.Remote.RemoteWorkspace._currentRemoteWorkspaceVersion"/> backwards.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Remote.RemoteWorkspace.InFlightSolution">
            <summary>
            Wrapper around asynchronously produced solution for a particular <see cref="F:Microsoft.CodeAnalysis.Remote.RemoteWorkspace.InFlightSolution.SolutionChecksum"/>.  The
            computation for producing the solution will be canceled when the number of in-flight operations using it
            goes down to 0.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Remote.RemoteWorkspace.InFlightSolution._cancellationTokenSource_doNotAccessDirectly">
            <summary>
            CancellationTokenSource controlling the execution of <see cref="F:Microsoft.CodeAnalysis.Remote.RemoteWorkspace.InFlightSolution._disconnectedSolutionTask"/> and <see
            cref="F:Microsoft.CodeAnalysis.Remote.RemoteWorkspace.InFlightSolution._primaryBranchTask"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Remote.RemoteWorkspace.InFlightSolution._disconnectedSolutionTask">
            <summary>
            Background work to just compute the disconnected solution associated with this <see cref="F:Microsoft.CodeAnalysis.Remote.RemoteWorkspace.InFlightSolution.SolutionChecksum"/>
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Remote.RemoteWorkspace.InFlightSolution._primaryBranchTask">
            <summary>
            Optional work to try to elevate the solution computed by <see cref="F:Microsoft.CodeAnalysis.Remote.RemoteWorkspace.InFlightSolution._disconnectedSolutionTask"/> to be
            the primary solution of this <see cref="T:Microsoft.CodeAnalysis.Remote.RemoteWorkspace"/>.  Must only be read/written while holding
            <see cref="F:Microsoft.CodeAnalysis.Remote.RemoteWorkspace._gate"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Remote.RemoteWorkspace.InFlightSolution.InFlightCount">
            <summary>
            Initially set to 1 to represent the operation that requested and is using this solution.  This also
            allows us to use 0 to represent a point that this solution computation is canceled and can not be
            used again.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Remote.RemoteWorkspace.InFlightSolution.TryKickOffPrimaryBranchWork_NoLock(System.Func{Microsoft.CodeAnalysis.Solution,System.Threading.CancellationToken,System.Threading.Tasks.Task{Microsoft.CodeAnalysis.Solution}})">
            <summary>
            Allow the RemoteWorkspace to try to elevate this solution to be the primary solution for itself.  This
            commonly happens because when a change happens to the host, features may kick off immediately, creating
            the disconnected solution, followed shortly afterwards by a request from the host to make that same
            checksum be the primary solution of this workspace.
            </summary>
            <param name="updatePrimaryBranchAsync"></param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Remote.RemoteWorkspace.InFlightSolution.DecrementInFlightCount_NoLock">
            <summary>
            Returns the in-flight solution computations <em>when</em> the in-flight-count is decremented to 0. This
            allows the caller to wait for those computations to complete (which will hopefully be quickly as they
            will have just been canceled).  This ensures the caller doesn't return back to the host (potentially
            unpinning the solution on the host) while the solution-computation tasks are still running and may still
            attempt to call into the host.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Remote.RemoteWorkspace.SolutionCreator">
            <summary>
            Create solution for given checksum from base solution
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Remote.RemoteWorkspace.SolutionCreator.#ctor(Microsoft.CodeAnalysis.Host.HostServices,Microsoft.CodeAnalysis.Remote.AssetProvider,Microsoft.CodeAnalysis.Solution)">
            <summary>
            Create solution for given checksum from base solution
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Remote.RemoteWorkspace._lastRequestedPrimaryBranchSolution">
            <summary>
            The last solution for the primary branch fetched from the client.  Cached as it's very common to have a
            flurry of requests for the same checksum that don't run concurrently.  Only read/write while holding <see
            cref="F:Microsoft.CodeAnalysis.Remote.RemoteWorkspace._gate"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Remote.RemoteWorkspace._lastRequestedAnyBranchSolution">
            <summary>
            The last solution requested by a service.  Cached as it's very common to have a flurry of requests for the
            same checksum that don't run concurrently.  Only read/write while holding <see cref="F:Microsoft.CodeAnalysis.Remote.RemoteWorkspace._gate"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Remote.RemoteWorkspace._solutionChecksumToSolution">
            <summary>
            Mapping from solution-checksum to the solution computed for it.  This is used so that we can hold a solution
            around as long as the checksum for it is being used in service of some feature operation (e.g.
            classification).  As long as we're holding onto it, concurrent feature requests for the same solution
            checksum can share the computation of that particular solution and avoid duplicated concurrent work.  Only
            read/write while holding <see cref="F:Microsoft.CodeAnalysis.Remote.RemoteWorkspace._gate"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Remote.RemoteWorkspace.GetOrCreateSolutionAndAddInFlightCount_NoLock(Microsoft.CodeAnalysis.Remote.AssetProvider,Microsoft.CodeAnalysis.Checksum,System.Int32,System.Boolean)">
            <summary>
            Deliberately not cancellable.  This code must always run fully to completion.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Remote.RemoteWorkspaceManager">
            <summary>
            Manages remote workspaces. Currently supports only a single, primary workspace of kind <see
            cref="F:Microsoft.CodeAnalysis.WorkspaceKind.RemoteWorkspace"/>. In future it should support workspaces of all kinds.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Remote.RemoteWorkspaceManager.Default">
            <summary>
            Default workspace manager used by the product. Tests may specify a custom <see
            cref="T:Microsoft.CodeAnalysis.Remote.RemoteWorkspaceManager"/> in order to override workspace services.
            </summary>
            <remarks>
            The general thinking behind these timings is that we don't want to be too aggressive constantly waking up
            and cleaning purging items from the cache.  But we also don't want to wait an excessive amount of time,
            allowing it to get too full.
            <para>
            Also note that the asset cache will not remove items associated with the <see
            cref="P:Microsoft.CodeAnalysis.Workspace.CurrentSolution"/> of the workspace it is created against.  This ensures that the assets
            associated with the solution that most closely corresponds to what the user is working with will stay pinned
            on the remote side and not get purged just because the user stopped interactive for a while.  This ensures
            the next sync (which likely overlaps heavily with the current solution) will not force the same assets to be
            resent.
            </para>
            <list type="bullet">
            <item>CleanupInterval=30s gives what feels to be a reasonable non-aggressive amount of time to let the cache
            do its job, while also making sure several times a minute it is scanned for things that can be
            dropped.</item>
            <item>PurgeAfter=1m effectively states that an item will be dumped from the cache if not used in the last
            minute.  This seems reasonable for keeping around all the parts of the current solutions in use, while
            allowing values from the past, or values removed from the solution to not persist too long.</item>
            <item>GcAfter=1m means that we'll force some GCs to happen after that amount of time of *non-activity*.  In
            other words, as long as OOP is being touched for operations, we will avoid doing the GCs.
            </item>
            </list>
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Remote.RemoteWorkspaceManager.GetSolutionAsync(Microsoft.ServiceHub.Framework.ServiceBrokerClient,Microsoft.CodeAnalysis.Checksum,System.Threading.CancellationToken)">
            <summary>
            Not ideal that we exposing the workspace solution, while not ensuring it stays alive for other calls using
            the same <paramref name="solutionChecksum"/>). However, this is used by Pythia/Razor/UnitTesting which all
            assume they can get that solution instance and use as desired by them.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Remote.SolutionAssetCache._remoteWorkspace">
            <summary>
            Workspace we are associated with.  When we purge items from teh cache, we will avoid any items associated
            with the items in its 'CurrentSolution'.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Remote.SolutionAssetCache._cleanupIntervalTimeSpan">
            <summary>
            Time interval we check storage for cleanup
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Remote.SolutionAssetCache._purgeAfterTimeSpan">
            <summary>
            Time span data can sit inside of cache (<see cref="F:Microsoft.CodeAnalysis.Remote.SolutionAssetCache._assets"/>) without being used.
            after that, it will be removed from the cache.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Remote.SolutionAssetCache._gcAfterTimeSpan">
            <summary>
            Time we will wait after the last activity before doing explicit GC cleanup.
            We monitor all resource access and service call to track last activity time.
            
            We do this since 64bit process can hold onto quite big unused memory when
            OOP is running as AnyCpu
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Remote.SolutionAssetCache.#ctor(Microsoft.CodeAnalysis.Remote.RemoteWorkspace,System.TimeSpan,System.TimeSpan,System.TimeSpan)">
            <summary>
            Create central data cache
            </summary>
            <param name="cleanupInterval">time interval to clean up</param>
            <param name="purgeAfter">time unused data can sit in the cache</param>
            <param name="gcAfter">time we wait before it call GC since last activity</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Remote.TestUtils.GetAssetMapAsync(Microsoft.CodeAnalysis.Solution,System.Threading.CancellationToken)">
            <summary>
            create checksum to correspoing object map from solution
            this map should contain every parts of solution that can be used to re-create the solution back
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Remote.TestUtils.GetAssetMapAsync(Microsoft.CodeAnalysis.Project,System.Threading.CancellationToken)">
            <summary>
            create checksum to corresponding object map from project this map should contain every parts of project that
            can be used to re-create the project back
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Remote.RemoteAssetSynchronizationService">
            <summary>
            This service is used by the SolutionChecksumUpdater to proactively update the solution snapshot in the
            out-of-process workspace. We do this to limit the amount of time required to synchronize a solution over after
            an edit once a feature is asking for a snapshot.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Remote.BrokeredServiceBase">
            <summary>
            Base type for Roslyn brokered services hosted in ServiceHub.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Remote.RemoteDiagnosticAnalyzerService.StartSolutionCrawlerAsync(System.Threading.CancellationToken)">
            <summary>
            Remote API.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Remote.RemoteDiagnosticAnalyzerService.CalculateDiagnosticsAsync(Microsoft.CodeAnalysis.Checksum,Microsoft.CodeAnalysis.Diagnostics.DiagnosticArguments,System.Threading.CancellationToken)">
            <summary>
            Calculate diagnostics. this works differently than other ones such as todo comments or designer attribute scanner
            since in proc and out of proc runs quite differently due to concurrency and due to possible amount of data
            that needs to pass through between processes
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Remote.RemoteGlobalNotificationDeliveryService.OnGlobalOperationStartedAsync(System.Threading.CancellationToken)">
            <summary>
            Remote API.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Remote.RemoteGlobalNotificationDeliveryService.OnGlobalOperationStoppedAsync(System.Threading.CancellationToken)">
            <summary>
            Remote API.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Remote.RemoteMissingImportDiscoveryService.SymbolSearchService">
            <summary>
            Provides an implementation of the <see cref="T:Microsoft.CodeAnalysis.SymbolSearch.ISymbolSearchService"/> on the remote side so that
            Add-Import can find results in nuget packages/reference assemblies.  This works
            by remoting *from* the OOP server back to the host, which can then forward this 
            appropriately to wherever the real <see cref="T:Microsoft.CodeAnalysis.SymbolSearch.ISymbolSearchService"/> is running.  This is necessary
            because it's not guaranteed that the real <see cref="T:Microsoft.CodeAnalysis.SymbolSearch.ISymbolSearchService"/> will be running in 
            the same process that is supplying the <see cref="T:Microsoft.CodeAnalysis.Remote.RemoteMissingImportDiscoveryService"/>.
            
            Ideally we would not need to bounce back to the host for this.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Remote.RemoteProcessTelemetryService.InitializeTelemetrySessionAsync(System.Int32,System.String,System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Remote API. Initializes ServiceHub process global state.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Remote.RemoteProcessTelemetryService.EnableLoggingAsync(System.Collections.Immutable.ImmutableArray{System.String},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Internal.Log.FunctionId},System.Threading.CancellationToken)">
            <summary>
            Remote API.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Remote.RemoteProcessTelemetryService.InitializeAsync(Microsoft.CodeAnalysis.Host.WorkspaceConfigurationOptions,System.Threading.CancellationToken)">
            <summary>
            Remote API.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Remote.RemoteProcessTelemetryService.PerformanceReporter">
            <summary>
            Track when last time report has sent and send new report if there is update after given internal
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Remote.RemoteSemanticClassificationService.s_semanticPersistenceName">
            <summary>
            Key we use to look this up in the persistence store for a particular document.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Remote.RemoteSemanticClassificationService.ClassificationFormat">
            <summary>
            Our current persistence version.  If we ever change the on-disk format, this should be changed so that we
            skip over persisted data that we cannot read.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Remote.RemoteSemanticClassificationService._cachedData">
            <summary>
            Cache of the previously requested classified spans for a particular document.  We use this so that during
            loading, if we're asking about the same documents multiple times by the classification service, we can just
            return what we have already loaded and not go back to the persistence store to read/decode.
            <para/>
            This can be read and updated from different threads.  To keep things safe, we use this object itself
            as the lock that is taken to serialize access.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Remote.RemoteSemanticClassificationService._workQueue">
            <summary>
            Queue where we place documents we want to compute and cache full semantic classifications for.  Note: the
            same document may appear multiple times inside of this queue (for different versions of the document).
            However, we'll only process the last version of any document added.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EditAndContinue.RemoteEditAndContinueService.StartDebuggingSessionAsync(Microsoft.CodeAnalysis.Checksum,Microsoft.CodeAnalysis.Remote.RemoteServiceCallbackId,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.DocumentId},System.Boolean,System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Remote API.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EditAndContinue.RemoteEditAndContinueService.BreakStateOrCapabilitiesChangedAsync(Microsoft.CodeAnalysis.EditAndContinue.DebuggingSessionId,System.Nullable{System.Boolean},System.Threading.CancellationToken)">
            <summary>
            Remote API.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EditAndContinue.RemoteEditAndContinueService.EndDebuggingSessionAsync(Microsoft.CodeAnalysis.EditAndContinue.DebuggingSessionId,System.Threading.CancellationToken)">
            <summary>
            Remote API.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EditAndContinue.RemoteEditAndContinueService.GetDocumentDiagnosticsAsync(Microsoft.CodeAnalysis.Checksum,Microsoft.CodeAnalysis.Remote.RemoteServiceCallbackId,Microsoft.CodeAnalysis.DocumentId,System.Threading.CancellationToken)">
            <summary>
            Remote API.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EditAndContinue.RemoteEditAndContinueService.EmitSolutionUpdateAsync(Microsoft.CodeAnalysis.Checksum,Microsoft.CodeAnalysis.Remote.RemoteServiceCallbackId,Microsoft.CodeAnalysis.EditAndContinue.DebuggingSessionId,System.Threading.CancellationToken)">
            <summary>
            Remote API.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EditAndContinue.RemoteEditAndContinueService.CommitSolutionUpdateAsync(Microsoft.CodeAnalysis.EditAndContinue.DebuggingSessionId,System.Threading.CancellationToken)">
            <summary>
            Remote API.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EditAndContinue.RemoteEditAndContinueService.DiscardSolutionUpdateAsync(Microsoft.CodeAnalysis.EditAndContinue.DebuggingSessionId,System.Threading.CancellationToken)">
            <summary>
            Remote API.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EditAndContinue.RemoteEditAndContinueService.GetBaseActiveStatementSpansAsync(Microsoft.CodeAnalysis.Checksum,Microsoft.CodeAnalysis.EditAndContinue.DebuggingSessionId,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.DocumentId},System.Threading.CancellationToken)">
            <summary>
            Remote API.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EditAndContinue.RemoteEditAndContinueService.GetAdjustedActiveStatementSpansAsync(Microsoft.CodeAnalysis.Checksum,Microsoft.CodeAnalysis.Remote.RemoteServiceCallbackId,Microsoft.CodeAnalysis.EditAndContinue.DebuggingSessionId,Microsoft.CodeAnalysis.DocumentId,System.Threading.CancellationToken)">
            <summary>
            Remote API.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EditAndContinue.RemoteEditAndContinueService.SetFileLoggingDirectoryAsync(System.String,System.Threading.CancellationToken)">
            <summary>
            Remote API.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Host.RemoteWorkspaceConfigurationService.Options">
            <summary>
            Returns default values until the options are initialized.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.UnusedReferences.ProjectAssets.ProjectAssetsFileReader.ReadReferencesAsync(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.UnusedReferences.ReferenceInfo},System.String)">
            <summary>
            Enhances references with the assemblies they bring into the compilation and their dependency hierarchy.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.ErrorReporting.FaultReporter.P4ModuleNameDefaultIndex">
            <summary>
            The bucket parameter for the blamed module.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.ErrorReporting.FaultReporter.P5MethodNameDefaultIndex">
            <summary>
            The bucket parameter for the blamed method.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ErrorReporting.FaultReporter.ReportFault(System.Exception,Microsoft.VisualStudio.Telemetry.FaultSeverity,System.Boolean)">
            <summary>
            Report Non-Fatal Watson for a given unhandled exception.
            </summary>
            <param name="exception">Exception that triggered this non-fatal error</param>
            <param name="forceDump">Force a dump to be created, even if the telemetry system is not
            requesting one; we will still do a client-side limit to avoid sending too much at once.</param>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Telemetry.AggregatingTelemetryLog">
            <summary>
            Provides a wrapper around the VSTelemetry histogram APIs to support aggregated telemetry. Each instance
            of this class corresponds to a specific FunctionId operation and can support aggregated values for each
            metric name logged.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Telemetry.AggregatingTelemetryLog.#ctor(Microsoft.VisualStudio.Telemetry.TelemetrySession,Microsoft.CodeAnalysis.Internal.Log.FunctionId,System.Double[],Microsoft.CodeAnalysis.Telemetry.AggregatingTelemetryLogManager)">
            <summary>
            Creates a new aggregating telemetry log
            </summary>
            <param name="session">Telemetry session used to post events</param>
            <param name="functionId">Used to derive meter name</param>
            <param name="bucketBoundaries">Optional values indicating bucket boundaries in milliseconds. If not specified, 
            all histograms created will use the default histogram configuration</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Telemetry.AggregatingTelemetryLog.Log(Microsoft.CodeAnalysis.Internal.Log.KeyValueLogMessage)">
            <summary>
            Adds aggregated information for the metric and value passed in via <paramref name="logMessage"/>. The Name/Value properties
            are used as the metric name and value to record.
            </summary>
            <param name="logMessage"></param>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Telemetry.AggregatingTelemetryLogManager">
            <summary>
            Manages creation and obtaining aggregated telemetry logs. Also, notifies logs to
            send aggregated events every 30 minutes.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Telemetry.TimedTelemetryLogBlock">
            <summary>
            Provides a mechanism to log telemetry information containing the execution time between
            creation and disposal of this object.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.LanguageServices.Telemetry.TelemetryLogProvider">
            <summary>
            Provides access to an appropriate <see cref="T:Microsoft.CodeAnalysis.Telemetry.ITelemetryLogProvider"/> for logging telemetry.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.LanguageServices.Telemetry.TelemetryLogProvider.GetLog(Microsoft.CodeAnalysis.Internal.Log.FunctionId)">
            <summary>
            Returns an <see cref="T:Microsoft.CodeAnalysis.Telemetry.ITelemetryLog"/> for logging telemetry.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.LanguageServices.Telemetry.TelemetryLogProvider.GetAggregatingLog(Microsoft.CodeAnalysis.Internal.Log.FunctionId,System.Double[])">
            <summary>
            Returns an aggregating <see cref="T:Microsoft.CodeAnalysis.Telemetry.ITelemetryLog"/> for logging telemetry.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.LanguageServices.Telemetry.TelemetryLogProvider.Flush">
            <summary>
            Flushes all telemetry logs
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.LanguageServices.Storage.CloudCachePersistentStorage">
            <summary>
            Implementation of Roslyn's <see cref="T:Microsoft.CodeAnalysis.Host.IPersistentStorage"/> sitting on top of the platform's cloud storage
            system.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.LanguageServices.Storage.CloudCachePersistentStorage.s_solutionKey">
            <remarks>
            We do not need to store anything specific about the solution in this key as the platform cloud cache is
            already keyed to the current solution.  So this just allows us to store values considering that as the root.
            </remarks>
        </member>
        <member name="F:Microsoft.VisualStudio.LanguageServices.Storage.CloudCachePersistentStorage.s_projectToContainerKeyCache">
            <summary>
            Cache from project green nodes to the container keys we've computed for it (and the documents inside of it).
            We can avoid computing these container keys when called repeatedly for the same projects/documents.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.LanguageServices.Storage.CloudCachePersistentStorage._cacheService">
            <summary>
            Underlying cache service (owned by platform team) responsible for actual storage and retrieval of data.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.LanguageServices.Storage.CloudCachePersistentStorage.GetContainerKey(Microsoft.CodeAnalysis.Storage.ProjectKey,Microsoft.CodeAnalysis.Project)">
            <summary>
            Maps our own roslyn key to the appropriate key to use for the cloud cache system.  To avoid lots of
            allocations we cache these (weakly) so if the same keys are used we can use the same platform keys.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.LanguageServices.Storage.CloudCachePersistentStorage.GetContainerKey(Microsoft.CodeAnalysis.Storage.DocumentKey,Microsoft.CodeAnalysis.Document)">
            <summary>
            Maps our own roslyn key to the appropriate key to use for the cloud cache system.  To avoid lots of
            allocations we cache these (weakly) so if the same keys are used we can use the same platform keys.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.LanguageServices.Storage.ProjectContainerKeyCache">
            <summary>
            Cache of our own internal roslyn storage keys to the equivalent platform cloud cache keys.  Cloud cache keys can
            store a lot of date in them (like their 'dimensions' dictionary.  We don't want to continually recreate these as
            we read/write date to the db.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.LanguageServices.Storage.ProjectContainerKeyCache.ProjectContainerKey">
            <summary>
            Container key explicitly for the project itself.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.LanguageServices.Storage.ProjectContainerKeyCache._documentToContainerKey">
            <summary>
            Cache from document green nodes to the container keys we've computed for it. We can avoid computing these
            container keys when called repeatedly for the same documents.
            </summary>
            <remarks>
            We can use a normal Dictionary here instead of a <see cref="T:System.Runtime.CompilerServices.ConditionalWeakTable`2"/> as
            instances of <see cref="T:Microsoft.VisualStudio.LanguageServices.Storage.ProjectContainerKeyCache"/> are always owned in a context where the <see
            cref="T:Microsoft.CodeAnalysis.ProjectState"/> is alive.  As that instance is alive, all <see cref="T:Microsoft.CodeAnalysis.TextDocumentState"/>s the project
            points at will be held alive strongly too.
            </remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.LanguageServices.Storage.FileDownloader.ReadFileAsync">
            <summary>
            The netcore version of <see cref="T:Microsoft.VisualStudio.RemoteControl.RemoteControlClient"/> doesn't support ReturnStale.  It will download the file
            (on a separate thread), but then not cache it because it doesn't have access to the normal IE component that
            does proper header reading/caching.  Then, when we call in to read the file, we get nothing back, since nothing
            was cached.
            <para/> The temporary solution to this is to force the download to happen.  This is not ideal as we will no
            longer be respecting the server "Cache-Control:Max-Age" header.  Which means we'll continually download the
            files, even if not needed (since the server says to use the local value).  This is not great, but is not
            terrible either.  First, we will only download the full DB file <em>once</em>, when it is actually missing on
            the user's machine.  From that point on, we'll only be querying the server for the delta-patch file for the DB
            version we have locally.  The vast majority of the time that is a tiny document of the form <c><![CDATA[<Patch
            upToDate="true" FileVersion="105" ChangesetId="1CBE1453" />]]></c> (around 70 bytes) which simply tells the user
            they are up to date.  Only about once every three months will they actually download a large patch file.  Also,
            this patch download will only happen once a day tops (as that is our cadence for checking if there are new index
            versions out).
            <para/> https://github.com/dotnet/roslyn/issues/71014 tracks this issue.  Once RemoteControlClient is updated to
            support this again, we can remove this specialized code for netcore.
            </summary>
        </member>
    </members>
</doc>
