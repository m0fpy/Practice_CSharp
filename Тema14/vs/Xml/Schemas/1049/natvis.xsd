<?xml version="1.0" encoding="utf-8"?>
<xs:schema targetNamespace="http://schemas.microsoft.com/vstudio/debugger/natvis/2010" xmlns="http://schemas.microsoft.com/vstudio/debugger/natvis/2010" attributeFormDefault="unqualified" elementFormDefault="qualified" xmlns:xs="http://www.w3.org/2001/XMLSchema">

  <!-- Definition of complex named types-->

  <xs:simpleType name="GuidType">
    <xs:annotation>
      <xs:documentation>Значения этого типа выглядят следующим образом: "01234567-89AB-CDEF-0123-456789ABCDEF" или "{01234567-89AB-CDEF-0123-456789ABCDEF}".</xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:string">
      <xs:pattern value="[{(]?[0-9A-Fa-f]{8}\-?[0-9A-Fa-f]{4}\-?[0-9A-Fa-f]{4}\-?[0-9A-Fa-f]{4}\-?[0-9A-Fa-f]{12}[})]?"/>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="CppIdType">
    <xs:annotation>
      <xs:documentation>Допустимый идентификатор C++.</xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:string">
      <xs:pattern value="[a-zA-Z$_][a-zA-Z$_0-9]*"/>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="StringType">
    <xs:restriction base="xs:string">
      <xs:minLength value="1"/>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="MaxItemsPerViewType">
    <xs:annotation>
      <xs:documentation>
        Задает, какое максимальное число элементов коллекции может показываться одновременно. Если число элементов коллекции
        превысит это значение, в конце будет создан специальный узел, который можно развернуть и просмотреть больше элементов.

        Максимальное число показываемых элементов в представлении можно настраивать. Большее значение позволяет показать больше элементов
        за один раз, а меньшее значение увеличивает производительность Visual Studio при разворачивании пользовательского списка объектов. В целом, 
        чем более сложна логика обхода, тем меньшее число элементов стоит показывать в одном представлении, чтобы сохранить скорость реагирования интерфейса IDE.

        Допустимое максимальное число элементов в представлении — от 1 до 50 000. Если этот атрибут не указан, будет использоваться значение по умолчанию — 5 000.
      </xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:unsignedInt">
      <xs:minInclusive value="1"/>
      <xs:maxInclusive value="50000"/>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="ConditionType">
    <xs:annotation>
      <xs:documentation>Указывает условие, при котором этого элемент является активным. Результатом вычисления этого выражения должно быть логическое значение.</xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:string">
      <xs:minLength value="1"/>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="OptionalType">
    <xs:annotation>
      <xs:documentation>
        Указывает, является ли элемент необязательным. При сбое анализа необязательного элемента можно использовать оставшиеся элементы во вложенной записи &lt;Type&gt;
.
        При сбое анализа обязательного элемента весь вложенный элемент &lt;Type&gt; будет считаться недействительным. Все элементы по умолчанию считаются обязательными,
        если параметру Optional не задано значение "true".
      </xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:boolean">
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="ViewIncludeType">
    <xs:annotation>
      <xs:documentation>
        Задает разделенный точками с запятыми список представлений, в которых должен быть показан этот элемент. Представление объекта управляется
        через указатель формата ",view(&lt;name&gt;)".
      </xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:string">
      <xs:minLength value="1"/>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="ViewExcludeType">
    <xs:annotation>
      <xs:documentation>
        Задает разделенный точками с запятыми список представлений, в которых должен быть скрыт этот элемент. Представление объекта управляется
        через указатель формата ",view(&lt;name&gt;)".
      </xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:string">
      <xs:minLength value="1"/>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="TypeNameType">
    <xs:annotation>
      <xs:documentation>Указывает полное имя визуализируемого типа. Если тип является классом шаблона, он может содержать символ "*" как подстановочный знак для параметров шаблона. С определениями UIVisualizer разрешается использовать только примитивные типы данных.</xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:string">
      <xs:minLength value="1"/>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="ModuleNameStringType">
    <xs:annotation>
      <xs:documentation>Указывает имя модуля. Оно должно включать только имя модуля без абсолютного или относительного пути.</xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:string">
      <xs:minLength value="1"/>
      <xs:pattern value="([^\\^//])+"/>
      <!-- Prevent absolute or relative pathing, just the module name only-->
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="VersionStringType">
    <xs:annotation>
      <xs:documentation>Разрешен формат 1.2.3.4 или 1.2.</xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:string">
      <xs:pattern value="([0-9])+\.([0-9])+(\.([0-9])+\.([0-9])+)?"/>
      <!--1.2.3.4 or 1.2 are acceptable -->
    </xs:restriction>
  </xs:simpleType>

  <xs:complexType name="AlternativeHResultType">
    <xs:annotation>
      <xs:documentation>Указывает альтернативный HRESULT, который будет использовать тот же визуализатор.</xs:documentation>
    </xs:annotation>
    <xs:attribute name="Name" type="TypeNameType" use="required"/>
  </xs:complexType>

  <xs:complexType name="IntrinsicParameterType">
    <xs:annotation>
      <xs:documentation>Указывает тип параметра для заданной встроенной функции.</xs:documentation>
    </xs:annotation>
    <xs:attribute name="Type" type="StringType" use="required"/>
    <xs:attribute name="Name" type="CppIdType" use="optional">
      <xs:annotation>
        <xs:documentation>Если выражение задано, указывает имя, по которому оно может ссылаться на параметр. Если функция реализована посредством расширения отладчика,
        этот атрибут можно опустить.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="IntrinsicType">
    <xs:annotation>
      <xs:documentation>Описывает настраиваемую встроенную функцию, которую можно вызвать из выражения.  Элемент &lt;Intrinsic&gt; должен
        сопровождаться компонентом отладчика, который реализует функцию с помощью интерфейса IDkmIntrinsicFunctionEvaluator140.
      </xs:documentation>
    </xs:annotation>
    <xs:choice minOccurs="0" maxOccurs="unbounded">
      <xs:element name="Parameter" minOccurs="0" maxOccurs="unbounded" type="IntrinsicParameterType"></xs:element>
    </xs:choice>
    <xs:attributeGroup ref="CommonAttributes_NoCondition_NoView"/>
    <xs:attribute name="Name" type="CppIdType" use="required">
      <xs:annotation>
        <xs:documentation>Название встроенной функции.  Должно являться действительным идентификатором C++.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="Category" type="IconType" use="optional">
      <xs:annotation>
        <xs:documentation>Указывает, какой значок категории должен назначаться результатам выражений, вызывающих эту функцию. Определяет, какой значок используется
        в окне контрольных значений для выражений, вызывающих функцию.  Значение категории по умолчанию — Method.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ReturnType" type="StringType" use="optional">
      <xs:annotation>
        <xs:documentation>Тип возвращаемого значения встроенной функции. Если задано выражение, тип возвращаемого значения можно опустить (он будет определяться типом выражения).</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="Expression" type="StringType" use="optional">
      <xs:annotation>
        <xs:documentation>
          Выражение, которое вычисляется в тип возвращаемого значения для функции.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="SourceId" type="GuidType" use="optional">
      <xs:annotation>
        <xs:documentation>Указывает идентификатор источника, который служит для определения компонента отладки, реализующего функцию. Должен совпадать с условиями фильтрации при реализации IDkmIntrinsicFunctionEvaluator140.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="LanguageId" type="GuidType" use="optional">
      <xs:annotation>
        <xs:documentation>Указывает идентификатор языка, который служит для определения компонента отладки, реализующего функцию. Должен совпадать с условиями фильтрации при реализации IDkmIntrinsicFunctionEvaluator140.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="Id" type="xs:unsignedInt" use="optional">
      <xs:annotation>
        <xs:documentation>Указывает уникальный идентификатор для этой функции с учетом идентификаторов источника и языка. Используется реализующим компонентом для определения того, вызов какой функции выполнялся
        в случае реализации нескольких встроенных функций.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="SideEffect" type="xs:boolean" use="optional">
      <xs:annotation>
        <xs:documentation>Если значение равно "true", указывает, что эта функция может иметь побочные действия.  Если значение равно "true", вызовы этой функции будут отключены
        в сценариях, где неожиданные побочные действия могут запутать пользователя. Для изменяющих состояние функций внутри отлаживаемого объекта или внутри Visual Studio следует задать значение "true".
        Значение по умолчанию — "false".</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="Varargs" type="xs:boolean" use="optional">
      <xs:annotation>
        <xs:documentation>
          Если значение равно "true", указывает, что функция является функцией varargs и что можно передать дополнительные аргументы после перечисленных явным образом параметров. Значение по умолчанию — "false".
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="AlternativeTypeType">
    <xs:annotation>
      <xs:documentation>Указывает альтернативный тип, который будет также использовать этот визуализатор.</xs:documentation>
    </xs:annotation>
    <xs:attribute name="Name" type="TypeNameType" use="required"/>
    <xs:attribute name="Priority" type="PriorityType" use="optional"/>
    <xs:attribute name="Inheritable" type="xs:boolean" use="optional">
      <xs:annotation>
        <xs:documentation>
          Значение "True", если этот визуализатор может использоваться объектами классов, полученных из данного типа; значение "False", если объект должен быть непосредственно этого типа, чтобы визуализатор перезапустился.
          Значение по умолчанию — True.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="VersionType">
    <xs:annotation>
      <xs:documentation>Указывает соответствующие имя и версию модуля для данного визуализатора.</xs:documentation>
    </xs:annotation>
    <xs:attribute name="Name" type="ModuleNameStringType" use="required"/>
    <xs:attribute name="Min" type="VersionStringType" use="optional">
      <xs:annotation>
        <xs:documentation>Указывает минимальный (включительный) номер версии. </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="Max" type="VersionStringType" use="optional">
      <xs:annotation>
        <xs:documentation>Указывает максимальный (включительный) номер версии. </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  
  <!-- Attributes for elements that support filtering by view-->
  <xs:attributeGroup name="ViewConstraints">
    <xs:attribute name="IncludeView" type="ViewIncludeType" use="optional"/>
    <xs:attribute name="ExcludeView" type="ViewExcludeType" use="optional"/>
  </xs:attributeGroup>

  <xs:attributeGroup name="CommonAttributes_NoCondition_NoView">
    <xs:attribute name="ModuleName" type="ModuleNameStringType" use="optional"/>
    <xs:attribute name="ModuleVersionMin" type="VersionStringType" use="optional"/>
    <xs:attribute name="ModuleVersionMax" type="VersionStringType" use="optional"/>
    <xs:attribute name="Optional" type="OptionalType" use="optional"/>
  </xs:attributeGroup>

  <xs:attributeGroup name="CommonAttributes_NoCondition">
    <xs:attributeGroup ref="CommonAttributes_NoCondition_NoView"/>
    <xs:attributeGroup ref="ViewConstraints"/>
  </xs:attributeGroup>

  <!-- These attributes are shared by all top-level natvis elements (DisplayString/StringView/top-level children of Expand)-->
  <xs:attributeGroup name="CommonAttributes">
    <xs:attributeGroup ref="CommonAttributes_NoCondition"/>
    <xs:attribute name="Condition" type="ConditionType" use="optional"/>
  </xs:attributeGroup>

  <xs:complexType name="DisplayStringType">
    <xs:annotation>
      <xs:documentation>Указывает строку, которая будет показана как значение объектов визуализируемого типа. Принимает произвольные строки в сочетании с выражениями. Все символы, заключенные в фигурные скобки (т. е. { and }), интерпретируются как выражения и вычисляются. В качестве escape-последовательности для фигурных скобок можно использовать двойные фигурные скобки (т. е. {{ или }}).</xs:documentation>
    </xs:annotation>
    <xs:simpleContent>
      <xs:extension base="xs:string">
        <xs:attributeGroup ref="CommonAttributes"/>
        <xs:attribute name="LegacyAddin" type="StringType" use="optional">
          <xs:annotation>
            <xs:documentation>При наличии устаревших надстроек указывает библиотеку DLL устаревшей надстройки. Если не указан полный путь, Visual Studio выполнит поиск в каталоге визуализатора, чтобы найти следующий NATVIS-файл, указывающий надстройку. По-прежнему разрешено использовать обычную отображаемую строку в сочетании с надстройкой; она будет использоваться как резервное значение, если не удастся загрузить библиотеку DLL надстройки.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="Export" type="StringType" use="optional">
          <xs:annotation>
            <xs:documentation>Указывает название экспорта для реализации устаревшей надстройки, если эта надстройка существует. Этот атрибут допустим только в том случае, если также указан атрибут LegacyAddin.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="Encoding" type="EncodingType" use="optional">
          <xs:annotation>
            <xs:documentation>Указывает кодировку строки, возвращаемой устаревшей надстройкой. По умолчанию — UTF8. Этот атрибут допустим только при указании атрибута LegacyAddin.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:simpleContent>
  </xs:complexType>

  <xs:simpleType name="EncodingType">
    <xs:restriction base="xs:normalizedString">
      <xs:enumeration value="Ansi"/>
      <xs:enumeration value="Utf8"/>
    </xs:restriction>
  </xs:simpleType>

  <xs:complexType name="CustomVisualizerType">
    <xs:annotation>
      <xs:documentation>Указывает надстройку визуализатора, которая настраивает представление отладчика для данного объекта.</xs:documentation>
    </xs:annotation>
    <xs:attribute name="VisualizerId" type="GuidType" use="required"/>
    <xs:attributeGroup ref="CommonAttributes"/>
  </xs:complexType>

  <xs:complexType name="StringViewType">
    <xs:annotation>
      <xs:documentation>Указывает выражение, значение которого отправляется во встроенные визуализаторы текста.</xs:documentation>
    </xs:annotation>
    <xs:simpleContent>
      <xs:extension base="StringType">
        <xs:attributeGroup ref="CommonAttributes"/>
      </xs:extension>
    </xs:simpleContent>
  </xs:complexType>

  <xs:complexType name="IndexNodeType">
    <xs:simpleContent>
      <xs:extension base="StringType">
        <xs:attribute name="Condition" type="ConditionType" use="optional"/>
      </xs:extension>
    </xs:simpleContent>
  </xs:complexType>

  <xs:attributeGroup name="NameAttribute">
  <xs:attribute type="xs:string" name="Name" use="optional">
    <xs:annotation>
      <xs:documentation>
        Указывает необязательное имя в синтаксисе &lt;DisplayString&gt; для этого узла. Если этот параметр опущен, именем
 узла будет индекс элемента в обходе дерева. Выражения в фигурных скобках
 вычисляются в контексте узла.
      </xs:documentation>
    </xs:annotation>
  </xs:attribute>    
  </xs:attributeGroup>
  
  <xs:complexType name="ListItemsNodeType">
    <xs:annotation>
      <xs:documentation>Выражение, которое указывает на значение узла связанного списка. Можно оставить его пустым или использовать this для ссылки на сам узел связанного списка. Это выражение вычисляется в контексте узла связанного списка, а не родительского типа связанного списка.</xs:documentation>
    </xs:annotation>
    <xs:simpleContent>
      <xs:extension base="StringType">
        <xs:attributeGroup ref="NameAttribute"/>
      </xs:extension>
    </xs:simpleContent>
  </xs:complexType>

  <xs:complexType name="TreeItemsNodeType">
    <xs:simpleContent>
      <xs:extension base="StringType">
        <xs:attribute name="Condition" type="ConditionType" use="optional"/>
        <xs:attributeGroup ref="NameAttribute"/>
      </xs:extension>
    </xs:simpleContent>
  </xs:complexType>

  <xs:complexType name="ItemType">
    <xs:annotation>
      <xs:documentation>Указывает один дочерний элемент. Принимает только выражения и не допускает произвольные строки. Если выражение создает значение сложного типа, сам дочерний узел может быть развернут пользователем.</xs:documentation>
    </xs:annotation>
    <xs:simpleContent>
      <xs:extension base="StringType">
        <xs:attribute name="Name" type="StringType" use="required">
          <xs:annotation>
            <xs:documentation>Имя дочернего элемента, которое будет отображаться в столбце имени в окнах переменных отладчика.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attributeGroup ref="CommonAttributes"/>
      </xs:extension>
    </xs:simpleContent>
  </xs:complexType>

  <xs:complexType name="ExpandedItemType">
    <xs:annotation>
      <xs:documentation>Указывает дочерний элемент, потомки которого будут отображаться в качестве дочерних элементов текущего узла. Используется, когда необходимо создать неструктурированное представление при развертывании типа.</xs:documentation>
    </xs:annotation>
    <xs:simpleContent>
      <xs:extension base="StringType">
        <xs:attributeGroup ref="CommonAttributes"/>
      </xs:extension>
    </xs:simpleContent>
  </xs:complexType>

  <xs:simpleType name="ArrayDirectionType">
    <xs:annotation>
      <xs:documentation>Указывает порядок развертывания индексов многомерных массивов. Значение Forward используется для развертывания массивов по строкам, а значение Backward - для развертывания массивов по столбцам.</xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:normalizedString">
      <xs:enumeration value="Forward"/>
      <xs:enumeration value="Backward"/>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="IconType">
    <xs:restriction base="xs:normalizedString">
      <xs:enumeration value="Data">
        <xs:annotation>
          <xs:documentation>
            Указывает, что элемент должен использовать значок, сопоставленный с общими данными.
          </xs:documentation>
        </xs:annotation>        
      </xs:enumeration>
      <xs:enumeration value="Method">
        <xs:annotation>
          <xs:documentation>
            Указывает, что элемент должен использовать значок, сопоставленный с вызовами методов.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="Property">
        <xs:annotation>
          <xs:documentation>
            Указывает, что элемент должен использовать значок, сопоставленный со свойствами.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>

  <xs:complexType name="ExpandType">
    <xs:annotation>
      <xs:documentation>Указывает список дочерних элементов, отображаемых при развертывании переменной визуализируемого типа в окнах отладчика.</xs:documentation>
    </xs:annotation>
    <xs:choice minOccurs="0" maxOccurs="unbounded">
      <xs:element name="Item" minOccurs="0" maxOccurs="unbounded" type="ItemType"/>
      <xs:element name="ArrayItems" minOccurs="0" maxOccurs="unbounded" type="ArrayItemsType"/>
      <xs:element name="IndexListItems" minOccurs="0" maxOccurs="unbounded" type="IndexListItemsType"/>
      <xs:element name="LinkedListItems" minOccurs="0" maxOccurs="unbounded" type="LinkedListItemsType"/>
      <xs:element name="TreeItems" minOccurs="0" maxOccurs="unbounded" type="TreeItemsType"/>
      <xs:element name="ExpandedItem" minOccurs="0" maxOccurs="unbounded" type="ExpandedItemType"/>
      <xs:element name="Synthetic" minOccurs="0" maxOccurs="unbounded" type="SyntheticItemType"/>
      <xs:element name="CustomListItems" minOccurs="0" maxOccurs="unbounded" type="CustomListItemsType"/>
    </xs:choice>
    <xs:attribute name="HideRawView" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>Указывает, должен ли узел "[Базовое представление]" этого объекта быть скрытым.  По умолчанию для этого атрибута задано значение false,
        из-за чего узел базового представления текущего объекта виден пользователю.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="CustomListItemsType">
    <xs:annotation>
      <xs:documentation>Позволяет настраивать логику для итераций по коллекции, которые не могут быть визуализированными иными способами.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:choice minOccurs="0" maxOccurs="unbounded">
        <xs:element name="Variable" minOccurs="0" maxOccurs="unbounded" type="VariableType"></xs:element>
      </xs:choice>
      <xs:choice minOccurs="0" maxOccurs="unbounded">
        <xs:element name="Size" minOccurs="1" maxOccurs="1" type="CustomListSizeType">
        </xs:element>
      </xs:choice>
      <xs:choice minOccurs="0" maxOccurs="1">
        <xs:element name="Skip" minOccurs="1" maxOccurs="1" type="SkipType"></xs:element>
      </xs:choice>
      <xs:choice minOccurs="0" maxOccurs="unbounded">
        <xs:group ref="CustomListCode"/>
      </xs:choice>
    </xs:sequence>
    <xs:attributeGroup ref="CommonAttributes"/>
    <xs:attribute name="MaxItemsPerView" type="MaxItemsPerViewType" use="optional">
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="SkipType">
    <xs:annotation>
      <xs:documentation>
        Указывает логику пропуска определенного числа элементов в коллекции. Логика пропуска активируется,
        когда пользователь прокручивает окно просмотра, чтобы быстро перейти вниз к нужной точке с обходом коллекции. После выполнения логики пропуска
        управление возвращается на начало выполнения, но переменные итерации будут изменены нужным образом, чтобы отразить обновленное состояние.

        Элемент &lt;Skip&gt; можно использовать для оптимизации производительности, он также позволяет быстро обходить большое
        число элементов в коллекции. Если элемент &lt;Skip&gt; не задан, вычислитель выражений запустит логику обхода, когда нужно совершать
        пропуск, пока не будет выполнено необходимое число элементов &lt;Item&gt;. В зависимости от структуры данных базовой коллекции
        для этого может потребоваться значительное количество ненужных расчетов.
      </xs:documentation>
    </xs:annotation>

    <xs:choice minOccurs="0" maxOccurs="unbounded">
      <xs:group ref="CustomListCode_NoItem"/>
    </xs:choice>

    <xs:attribute name="Value" type="CppIdType" use="required">
      <xs:annotation>
        <xs:documentation>
          Имя переменной, которая задает число элементов для пропуска в виде 32-разрядного целого числа без знака. Если указан элемент &lt;Size&gt;,
          вычислитель выражений никогда не передаст значение пропуска, из-за которого текущий индекс обхода превысит границы коллекции.
          Если элемент &lt;Size&gt; не указан, значением пропуска может быть любое произвольное целое число, и в этом случае именно логика пропуска &lt;Skip&gt;
           выполняет необходимые проверки границ. Если невозможно пропустить полное число запрошенных элементов, логика &lt;Skip&gt;
          изменит значение переменной пропуска таким образом, чтобы после завершения переменная содержала число фактически пропущенных элементов.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="CustomListSizeType">
    <xs:annotation>
      <xs:documentation>Указывает итоговое число элементов в коллекции.</xs:documentation>
    </xs:annotation>
    <xs:simpleContent>
      <xs:extension base="StringType">
        <xs:attribute name="Condition" type="ConditionType" use="optional"/>
      </xs:extension>
    </xs:simpleContent>
  </xs:complexType>

  <xs:group name="CustomListCode_NoItem">
    <xs:choice>
      <!-- For the sake of simplifying implementation, I am not implementing declaring variables inside of an 'loop' block
           until I encounter a scenario that requires it.-->
      <!--<xs:element name="Variable" minOccurs="0" maxOccurs="unbounded" type="VariableType"></xs:element>-->
      <xs:element name="Loop" minOccurs="0" maxOccurs="unbounded" type="LoopType_NoItem"></xs:element>
      <xs:sequence minOccurs="0" maxOccurs="unbounded">
        <xs:element name="If" minOccurs="1" maxOccurs="1" type="IfType_NoItem"></xs:element>
        <xs:element name="Elseif" minOccurs="0" maxOccurs="unbounded" type="IfType_NoItem"></xs:element>
        <xs:element name="Else" minOccurs="0" maxOccurs="1" type="ElseType_NoItem"></xs:element>
      </xs:sequence>
      <xs:element name="Exec" minOccurs="0" maxOccurs="unbounded" type="ExecType"></xs:element>
      <xs:element name="Break" minOccurs="0" maxOccurs="unbounded" type="BreakType"></xs:element>
    </xs:choice>
  </xs:group>

  <xs:group name="CustomListCode">
    <xs:choice>
      <!-- For the sake of simplifying implementation, I am not implementing declaring variables inside of an 'loop' block
          until I encounter a scenario that requires it.-->
      <!--<xs:element name="Variable" minOccurs="0" maxOccurs="unbounded" type="VariableType"></xs:element>-->
      <xs:element name="Loop" minOccurs="0" maxOccurs="unbounded" type="LoopType"></xs:element>
      <xs:sequence minOccurs="0" maxOccurs="unbounded">
        <xs:element name="If" minOccurs="1" maxOccurs="1" type="IfType"></xs:element>
        <xs:element name="Elseif" minOccurs="0" maxOccurs="unbounded" type="IfType"></xs:element>
        <xs:element name="Else" minOccurs="0" maxOccurs="1" type="ElseType"></xs:element>
      </xs:sequence>
      <xs:element name="Exec" minOccurs="0" maxOccurs="unbounded" type="ExecType"></xs:element>
      <xs:element name="Break" minOccurs="0" maxOccurs="unbounded" type="BreakType"></xs:element>
      <xs:element name="Item" minOccurs="0" maxOccurs="unbounded" type="CustomListItemType"></xs:element>
    </xs:choice>
  </xs:group>

  <xs:attributeGroup name="CustomListCode_Attributes">
    <xs:attribute name="Condition" type="ConditionType" use="optional">
      <xs:annotation>
        <xs:documentation>Условие, определяющее нужно ли выполнять этот и внутренние элементы</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attributeGroup ref="CustomListCode_Attributes_NoCondition"/>
  </xs:attributeGroup>

  <!-- Defines attributes that do on custom list code elements besides the condition.  Currently, this is empty, but maintaining the group
  as a placeholder in case we decide to add something to it later. -->
  <xs:attributeGroup name="CustomListCode_Attributes_NoCondition">
  </xs:attributeGroup>

  <xs:complexType name="LoopType_NoItem">
    <xs:annotation>
      <xs:documentation>Указывает блок инструкций, которые будут выполняться несколько раз до тех пор, пока не встретится элемент &lt;Break&gt; или нельзя будет вычислить выражение.</xs:documentation>
    </xs:annotation>

    <xs:choice minOccurs="0" maxOccurs="unbounded">
      <xs:group ref="CustomListCode_NoItem"/>
    </xs:choice>

    <xs:attributeGroup ref="CustomListCode_Attributes"/>
  </xs:complexType>


  <xs:complexType name="LoopType">
    <xs:annotation>
      <xs:documentation>Указывает блок инструкций, которые будут выполняться несколько раз до тех пор, пока не встретится элемент &lt;Break&gt; или нельзя будет вычислить выражение.</xs:documentation>
    </xs:annotation>

    <xs:choice minOccurs="0" maxOccurs="unbounded">
      <xs:group ref="CustomListCode"/>
    </xs:choice>

    <xs:attributeGroup ref="CustomListCode_Attributes"/>
  </xs:complexType>

  <xs:complexType name="IfType_NoItem">
    <xs:annotation>
      <xs:documentation>Указывает блок инструкций, которые будут выполняться, только если значение условия является истинным.</xs:documentation>
    </xs:annotation>

    <xs:choice minOccurs="0" maxOccurs="unbounded">
      <xs:group ref="CustomListCode_NoItem"/>
    </xs:choice>

    <xs:attributeGroup ref="CustomListCode_Attributes"/>
  </xs:complexType>

  <xs:complexType name="IfType">
    <xs:annotation>
      <xs:documentation>Указывает блок инструкций, которые будут выполняться, только если значение условия является истинным.</xs:documentation>
    </xs:annotation>

    <xs:choice minOccurs="0" maxOccurs="unbounded">
      <xs:group ref="CustomListCode"/>
    </xs:choice>

    <xs:attributeGroup ref="CustomListCode_Attributes"/>
  </xs:complexType>

  <xs:complexType name="ElseType_NoItem">
    <xs:annotation>
      <xs:documentation>Указывает блок инструкций, которые будут выполняться, только если значение условия является истинным.</xs:documentation>
    </xs:annotation>

    <xs:choice minOccurs="0" maxOccurs="unbounded">
      <xs:group ref="CustomListCode_NoItem"/>
    </xs:choice>

    <xs:attributeGroup ref="CustomListCode_Attributes_NoCondition"/>
  </xs:complexType>

  <xs:complexType name="ElseType">
    <xs:annotation>
      <xs:documentation>Указывает блок инструкций, которые будут выполняться, только если значение условия является истинным.</xs:documentation>
    </xs:annotation>

    <xs:choice minOccurs="0" maxOccurs="unbounded">
      <xs:group ref="CustomListCode"/>
    </xs:choice>

    <xs:attributeGroup ref="CustomListCode_Attributes_NoCondition"/>
  </xs:complexType>

  <xs:complexType name="VariableType">
    <xs:annotation>
      <xs:documentation>
        Объявляется переменную для использования в будущих выражениях с блоком &lt;CustomListItems&gt;.
      </xs:documentation>
    </xs:annotation>
    <xs:attribute name="Name" type="CppIdType" use="required">
      <xs:annotation>
        <xs:documentation>Имя переменной.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="InitialValue" type="StringType" use="required">
      <xs:annotation>
        <xs:documentation>
          Выражение, вычисляющее исходное значение переменной.
          Это выражение также указывает тип переменной. Выражения исходных значений могут использовать другие уже заданные переменные.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="ExecType">
    <xs:annotation>
      <xs:documentation>
        Выполняет единственное выражение. Выражение выполняется в контексте объекта, но может использовать переменные итераций.
        Выражение может изменять переменные итераций, больше никаких побочных эффектов не допускается.
      </xs:documentation>
    </xs:annotation>
    <xs:simpleContent>
      <xs:extension base="xs:string">
        <xs:attributeGroup ref="CustomListCode_Attributes"/>
      </xs:extension>
    </xs:simpleContent>
  </xs:complexType>

  <xs:complexType name="CustomListItemType">
    <xs:annotation>
      <xs:documentation>Создает дочерний элемент через вычисление данного выражения.</xs:documentation>
    </xs:annotation>
    <xs:simpleContent>
      <xs:extension base="StringType">
        <xs:attributeGroup ref="CustomListCode_Attributes"/>
        <xs:attribute name="Name" type="xs:string" use="optional">
          <xs:annotation>
            <xs:documentation>
              Указывает необязательное имя для элемента.  Имя предоставлено в синтаксисе &lt;DisplayString&gt; и может содержать внедренные выражения.
              Если имя не указано, используется имя по умолчанию в виде "[i]", где "i" — это индекс, представляющий собой элементы в порядке возвращения.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:simpleContent>
  </xs:complexType>

  <xs:complexType name="BreakType">
    <xs:annotation>
      <xs:documentation>Разрыв самого внутреннего элемента &lt;Loop&gt;.  Элемент &lt;Break&gt; за пределами цикла прекратит итерацию коллекции.</xs:documentation>
    </xs:annotation>
    <xs:attributeGroup ref="CustomListCode_Attributes"/>
  </xs:complexType>

  <xs:complexType name="SyntheticItemType">
    <xs:annotation>
      <xs:documentation>Указывает дочерний элемент, чье значение подтверждается выражением. Значение элемента можно указать с помощью элемента "DisplayString". Дочерние элементы этого элемента можно указывать с помощью элемента "Expand".</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element minOccurs="0" maxOccurs="unbounded" name="CustomVisualizer" type="CustomVisualizerType"/>
      <xs:element minOccurs="0" maxOccurs="unbounded" name="DisplayString" type="DisplayStringType"/>
      <xs:element minOccurs="0" maxOccurs="unbounded" name="StringView" type="StringViewType"/>
      <xs:element minOccurs="0" name="Expand" type="ExpandType"/>
    </xs:sequence>
    <xs:attribute name="Name" type="StringType" use="required">
      <xs:annotation>
        <xs:documentation>Имя дочернего элемента, которое будет отображаться в столбце имени в окнах отладчика.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="Expression" type="StringType" use="optional">
      <xs:annotation>
        <xs:documentation>Выражение будет использоваться для получения значения элемента, когда пользователю нужно его отследить отдельно с помощью команды "Добавить контрольное значение", примененной к элементу.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attributeGroup ref="CommonAttributes"/>
  </xs:complexType>

  <xs:complexType name="ValuePointerType">
    <xs:simpleContent>
      <xs:extension base="StringType">
        <xs:attribute name="Condition" type="ConditionType" use="optional"/>
      </xs:extension>
    </xs:simpleContent>
  </xs:complexType>

  <xs:complexType name="SizeType">
    <xs:simpleContent>
      <xs:extension base="StringType">
        <xs:attributeGroup ref="CommonAttributes"/>
      </xs:extension>
    </xs:simpleContent>
  </xs:complexType>

  <xs:complexType name="ArrayItemsType">
    <xs:annotation>
      <xs:documentation>Указывает представление содержимого переменной в виде массива. Предполагает, что элементы данных хранятся в памяти в нефрагментированном виде.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element minOccurs="0" maxOccurs="1" name="Direction" type="ArrayDirectionType"/>
      <xs:element minOccurs="0" maxOccurs="1" name="Rank" type="StringType">
        <xs:annotation>
          <xs:documentation>Указывает ранг массива.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element minOccurs="1" maxOccurs="unbounded" name="Size" type="SizeType">
        <xs:annotation>
          <xs:documentation>Указывает размер каждого измерения массива. Для многомерных массивов можно указать выражение, использующее неявный параметр $i. Вместо этого параметра будет подставляться индекс измерения для определения размера массива по соответствующему измерению.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element minOccurs="0" maxOccurs="1" name="LowerBound" type="StringType">
        <xs:annotation>
          <xs:documentation>Указывает нижнюю границу каждого измерения массива. Для многомерных массивов можно указать выражение, использующее неявный параметр $i. Вместо этого параметра будет подставляться индекс измерения для определения нижней границы массива по соответствующему измерению.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element minOccurs="1" maxOccurs="unbounded" name="ValuePointer" type="ValuePointerType">
        <xs:annotation>
          <xs:documentation>Задает выражение, которое указывает первый элемент массива. Выражение должно быть указателем типа элемента, отличного от void*.</xs:documentation>
        </xs:annotation>
      </xs:element>
    </xs:sequence>
    <xs:attributeGroup ref="CommonAttributes"/>
  </xs:complexType>

  <xs:complexType name="IndexListItemsType">
    <xs:annotation>
      <xs:documentation>Указывает более обобщенную форму представления переменной в виде массива. Используется, если элементы данных хранятся в памяти во фрагментированном виде и необходимо вычислять индекс элементов данных.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element minOccurs="1" maxOccurs="unbounded" name="Size" type="SizeType">
        <xs:annotation>
          <xs:documentation>Указывает размер списка индексов.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element minOccurs="1" maxOccurs="unbounded" name="ValueNode" type="IndexNodeType">
        <xs:annotation>
          <xs:documentation>Задает выражение, использующее неявный параметр $i, который указывает на элемент с номером i.</xs:documentation>
        </xs:annotation>
      </xs:element>
    </xs:sequence>
    <xs:attributeGroup ref="CommonAttributes"/>
  </xs:complexType>

  <xs:complexType name="LinkedListItemsType">
    <xs:annotation>
      <xs:documentation>Указывает представление содержимого переменной в виде связанного списка.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element minOccurs="0" maxOccurs="unbounded" name="Size" type="SizeType">
        <xs:annotation>
          <xs:documentation>Указывает количество элементов в связанном списке. Если указаны элементы с несколькими размерами, первый элемент размера с условием true (или без условий)
          определит размер. Если размер не указан (или все элементы размера имеют условие false), отладчик просмотрит список, чтобы узнать размер. Рекомендуется по возможности указывать размер связанных списков
          в записях NATVIS, так как это повысит производительность отладчика.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element maxOccurs="1" name="HeadPointer" type="StringType">
        <xs:annotation>
          <xs:documentation>Выражение, которое указывает на первый узел связанного списка.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element maxOccurs="1" name="NextPointer" type="StringType">
        <xs:annotation>
          <xs:documentation>Выражение, которое указывает на следующий элемент. Это выражение вычисляется в контексте узла связанного списка, а не родительского типа связанного списка.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element maxOccurs="1" name="ValueNode" type="ListItemsNodeType">
      </xs:element>
    </xs:sequence>
    <xs:attributeGroup ref="CommonAttributes"/>
  </xs:complexType>

  <xs:complexType name="TreeItemsType">
    <xs:annotation>
      <xs:documentation>Указывает представление содержимого переменной в виде дерева.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element minOccurs="0" maxOccurs="1" name="Size" type="StringType">
        <xs:annotation>
          <xs:documentation>Размер дерева.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element maxOccurs="1" name="HeadPointer" type="StringType">
        <xs:annotation>
          <xs:documentation>Выражение, которое указывает на корневой узел дерева.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element maxOccurs="1" name="LeftPointer" type="StringType">
        <xs:annotation>
          <xs:documentation>Выражение, которое указывает на левый дочерний элемент узла дерева. Это выражение вычисляется в контексте узла дерева, а не родительского типа.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element maxOccurs="1" name="RightPointer" type="StringType">
        <xs:annotation>
          <xs:documentation>Выражение, которое указывает на правый дочерний элемент узла дерева. Это выражение вычисляется в контексте узла дерева, а не родительского типа.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element maxOccurs="1" name="ValueNode" type="TreeItemsNodeType">
        <xs:annotation>
          <xs:documentation>Выражение, которое указывает на значение узла дерева. Можно оставить его пустым или использовать this для ссылки на сам узел дерева. Это выражение вычисляется в контексте узла дерева, а не родительского типа.</xs:documentation>
        </xs:annotation>
      </xs:element>
    </xs:sequence>
    <xs:attributeGroup ref="CommonAttributes"/>
  </xs:complexType>

  <xs:complexType name="UIVisualizerItemType">
    <xs:annotation>
      <xs:documentation>Указывает визуализатор пользовательского интерфейса, который может обрабатывать объекты этого типа. Визуализатор пользовательского интерфейса должен быть предварительно определен в NATVIS-файле.</xs:documentation>
    </xs:annotation>
    <xs:simpleContent>
      <xs:extension base="xs:string">
        <xs:attribute name="ServiceId" type="GuidType" use="required">
          <xs:annotation>
            <xs:documentation>GUID службы визуализатора.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="Id" type="xs:int" use="required">
          <xs:annotation>
            <xs:documentation>Указывает идентификатор визуализатора. Используется для разделения нескольких средств просмотра, предоставляемых службой визуализатора.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:simpleContent>
  </xs:complexType>

  <xs:complexType name="FavoritesItemType">
    <xs:annotation>
      <xs:documentation>Задает коллекцию элементов избранного для типа. Эти значения отображаются как первые дочерние элементы заданного элемента и входят в отображаемую строку по умолчанию.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element minOccurs="0" maxOccurs="unbounded" name="Favorite" type="FavoriteItemType"/>
    </xs:sequence>
  </xs:complexType>

  <xs:complexType name="FavoriteItemType">
    <xs:annotation>
      <xs:documentation>Задает элемент избранного для типа.</xs:documentation>
    </xs:annotation>
    <xs:simpleContent>
      <xs:extension base="xs:string"/>
    </xs:simpleContent>
  </xs:complexType>

  <xs:complexType name="MostDerivedObjectType">
    <xs:annotation>
      <xs:documentation>
        Указывает выражение, вычисляемое по текущему объекту, приведенному к полному производному (most-derived) типу.  
        
       В большинстве случаев отладчик может определить полный производный тип объекта автоматически, и тогда использование элемента &lt;MostDerivedType&gt;
        не требуется. Для автоматического определения полного производного типа объекта необходимо, чтобы объект являлся экземпляром класса C++ с таблицей виртуальных функций,
        созданной компилятором.  Этого достаточно для большинства иерархий классов. Тем не менее, иногда может требоваться настраиваемая логика,
        если иерархия классов не содержит виртуальных функций или если таблица виртуальных функций сформирована вручную
         с помощью кода приложения.
      </xs:documentation>
    </xs:annotation>
    
    <xs:simpleContent>
      <xs:extension base="StringType">
        <xs:attributeGroup ref="CommonAttributes"/>
        <xs:attribute name="IgnoreVTable" type="xs:boolean" use="optional">
          <xs:annotation>
            <xs:documentation>
              Если верно, указывает, что наиболее производный тип объекта всегда будет статическим типом указанного выражения.  По умолчанию
 отладчик будет использовать виртуальные таблицы для вычисления наиболее производного типа указанных выражений этого типа. Этот параметр следует
              использовать только в том случае, если код приложения создает виртуальные таблицы с использованием пользовательской логики, которую отладчик не распознает.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:simpleContent>
  </xs:complexType>

  <xs:simpleType name="SmartPointerUsage">
    <xs:annotation>
      <xs:documentation>Указывает, как смарт-указатель можно использовать синтаксически.</xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:normalizedString">
      <xs:enumeration value="Minimal">
        <xs:annotation>
          <xs:documentation>
            Указывает, что смарт-указатель можно использовать синтаксически исключительно в целях разыменования и сравнения.
            Определяет следующие перегруженные операторы:
            - operator*()    (разыменование)
            - operator-&gt;()   (доступ к полю разыменованного значения)
            - operator==()   (сравнение с необработанным указателем или другим смарт-указателем того же типа)
            - operator!=()   (сравнение с необработанным указателем или другим смарт-указателем того же типа)
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="Indexable">
        <xs:annotation>
          <xs:documentation>
            Указывает, что смарт-указатель можно использовать синтаксически в целях разыменования и сравнения, а также индексирования
            Определяет следующие перегруженные операторы:
            - operator+()  (добавление смещения типа size_t)
            - operator-()  (вычитание смещения типа size_t)
            - operator[]   (добавление смещения типа size_t и разыменование)
            - Все операторы, поддерживаемые SmartPointerUsage="Minimal"
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="Full">
        <xs:annotation>
          <xs:documentation>
            Указывает, что смарт-указатель будет содержать оператор преобразования для базового указателя. Все допустимые варианты применения базового
            указателя в этом языке можно использовать через оператор преобразования. Прямое назначение смарт-указателю все еще запрещено;
            чтобы изменить внутренний указатель в выражении, необходимо сделать это явным образом.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>

  <xs:complexType name="SmartPointerType">
    <xs:annotation>
      <xs:documentation>
        Указывает, что заданный тип является смарт-указателем. Текст внутри этого элемента указывает выражение для вычисления базового указателя.
        
        Элемент &lt;SmartPointer&gt; оказывает следующее влияние:
          - Если не задан альтернативный элемент &lt;DisplayString&gt; (либо все элементы &lt;DisplayString&gt; содержат ошибки), базовый указатель будет отображаемой строкой
          - Если не задан альтернативный элемент &lt;StringView&gt; (либо все элементы &lt;StringView&gt; содержат ошибки), базовый указатель будет строковым представлением при его наличии.
          - Если не задан альтернативный элемент &lt;Expand&gt;, расширение смарт-указателя будет соответствовать расширению базового указателя.
          - Класс смарт-указателя также будет поддерживать перегруженные указатели в соответствии со значением атрибута &lt;Usage&gt;. Вы можете явно отказаться от такого поведения, указав 
              "DefaultExpansion="false""
      </xs:documentation>
    </xs:annotation>
    <xs:simpleContent>
      <xs:extension base="StringType">
        <xs:attributeGroup ref="CommonAttributes_NoCondition"/>
        <xs:attribute name="Usage" type="SmartPointerUsage" use="required">
          <xs:annotation>
            <xs:documentation>Указывает, какие сочетания операторов поддерживает данный смарт-указатель.              
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="DefaultExpansion" type="xs:boolean" use="optional">
          <xs:annotation>
            <xs:documentation>
              Если значение равно true и отсутствует элемент Expand, предоставляется расширение по умолчанию, зависящее от расширения
              базового указателя.  Если значение равно false, автоматическое создание элемента &lt;Expand&gt; по
              смарт-указателю не выполняется. Если этот атрибут отсутствует, используется значение по умолчанию, "true".
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:simpleContent>
  </xs:complexType>

  <xs:complexType name="VisualizerType">
    <xs:annotation>
      <xs:documentation>Указывает запись визуализатора, которая настраивает представление отладчика для типа.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element minOccurs="0" maxOccurs="unbounded" name="AlternativeType" type="AlternativeTypeType"/>
      <xs:element minOccurs="0" maxOccurs="1" name="Version" type="VersionType"/>
      <xs:choice minOccurs="0" maxOccurs="1">
        <xs:sequence>
          <xs:element minOccurs="0" maxOccurs="unbounded" name="Intrinsic" type="IntrinsicType"/>
          <xs:element minOccurs="0" maxOccurs="unbounded" name="MostDerivedType" type="MostDerivedObjectType"/>
          <xs:element minOccurs="0" maxOccurs="unbounded" name="CustomVisualizer" type="CustomVisualizerType"/>
          <xs:element minOccurs="0" maxOccurs="1" name="SmartPointer" type="SmartPointerType"/>
          <xs:element minOccurs="0" maxOccurs="unbounded" name="DisplayString" type="DisplayStringType"/>
          <xs:element minOccurs="0" maxOccurs="unbounded" name="StringView" type="StringViewType"/>
          <xs:element minOccurs="0" name="Expand" type="ExpandType"/>
          <xs:element minOccurs="0" maxOccurs="1" name="Favorites" type="FavoritesItemType"/>
        </xs:sequence>
        <xs:element minOccurs="0" maxOccurs="unbounded" name="UIVisualizer" type="UIVisualizerItemType"/>
      </xs:choice>
    </xs:sequence>
    <xs:attribute name="Name" type="TypeNameType" use="required"/>
    <xs:attributeGroup ref="ViewConstraints"/>
    <xs:attribute name="Priority" type="PriorityType"/>
    <xs:attribute name="Inheritable" type="xs:boolean" use="optional">
      <xs:annotation>
        <xs:documentation>
          Значение "True", если этот визуализатор может использоваться объектами классов, полученных из данного типа; значение "False", если объект должен быть непосредственно этого типа, чтобы визуализатор перезапустился.
          Значение по умолчанию — True.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:simpleType name="PriorityType">
    <xs:annotation>
      <xs:documentation>Указывает дополнительный приоритет, назначаемый этой записи для определения соответствия типов. В первую очередь
       проверяются записи с более высоким приоритетом, находящиеся в конкретном файле или каталоге. Записи &lt;Type&gt; с неуказанным приоритетом по умолчанию получают приоритет "Средний". Записи &lt;AlternativeType&gt; с неуказанным приоритетом 
      наследуют приоритет элемента &lt;Type&gt;, в котором они содержатся. Приоритет используется только в случае отсутствия других средств устранения неоднозначности при определении соответствия типов.
      Например, записи с более точными определениями создания экземпляров шаблонов, ограничениями по модулям или представлениям будут пользоваться более высоким приоритетом независимо от указанных значений приоритетов.   
      Аналогично, независимо от приоритета, NATVIS-файлы, входящие в состав загруженного проекта, всегда имеют более высокую очередность по отношению к файлам в пользовательском каталоге NATVIS, 
      которые, в свою очередь, пользуются более высокой очередностью по отношению к файлам в каталоге NATVIS общесистемного уровня.   
      
      Если две записи имеют одинаковый приоритет и нет других признаков для устранения неоднозначности, то невозможно установить, какую из них следует использовать.
      </xs:documentation>
    </xs:annotation>
    <xs:union>
      <xs:simpleType>
        <xs:restriction base="xs:string">
          <xs:enumeration value="Low"/>
          <xs:enumeration value="MediumLow"/>
          <xs:enumeration value="Medium"/>
          <xs:enumeration value="MediumHigh"/>
          <xs:enumeration value="High"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:union>
  </xs:simpleType>

  <xs:complexType name="UIVisualizerType">
    <xs:annotation>
      <xs:documentation>Указывает сведения о визуализаторе пользовательского интерфейса, который создает собственный интерфейс для отображения объекта. Чтобы связать тип с визуализатором пользовательского интерфейса, запись визуализатора для этого типа должна ссылаться на визуализатор пользовательского интерфейса.</xs:documentation>
    </xs:annotation>
    <xs:simpleContent>
      <xs:extension base="xs:string">
        <xs:attribute name="ServiceId" type="GuidType" use="required">
          <xs:annotation>
            <xs:documentation>Указывает GUID службы визуализатора. Служба должна быть предоставлена пакетом Visual Studio, который также реализует интерфейс IVsCppDebugUIVisualizer. Отладчик загружает пакет, только если пользователь запрашивает эту службу визуализации.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="Id" type="xs:int" use="required">
          <xs:annotation>
            <xs:documentation>Указывает идентификатор визуализатора. Используется для разделения нескольких средств просмотра, предоставляемых этой службой визуализатора.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="MenuName" type="xs:string" use="required">
          <xs:annotation>
            <xs:documentation>Указывает имя, которое будет отображаться в списке визуализатора пользовательского интерфейса для переменной.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="Description" type="xs:string" use="optional">
          <xs:annotation>
            <xs:documentation>Указывает описание визуализатора пользовательского интерфейса.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:simpleContent>
  </xs:complexType>

  <xs:complexType name="HResultType">
    <xs:annotation>
      <xs:documentation>Указывает запись визуализатора, которая настраивает представление отладчика для HRESULT.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element minOccurs="0" maxOccurs="unbounded" name="AlternativeHResult" type="AlternativeHResultType">
        <xs:annotation>
          <xs:documentation>Другие типы HResult, которые будут совместно использовать тот же визуализатор.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element minOccurs="1" maxOccurs="1" name="HRValue" type="StringType">
        <xs:annotation>
          <xs:documentation>32-битовое значение HRESULT, предназначенное для настройки.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element minOccurs="0" maxOccurs="1" name="HRDescription" type="StringType">
        <xs:annotation>
          <xs:documentation>Описание этого значения HRESULT, которое будет отображаться в окнах отладчика.</xs:documentation>
        </xs:annotation>
      </xs:element>
    </xs:sequence>
    <xs:attribute name="Name" type="StringType" use="required">
      <xs:annotation>
        <xs:documentation>Имя значения HRESULT, которое будет отображаться в окнах отладчика.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="LocalizedStringType">
    <xs:annotation>
      <xs:documentation>
        Определяет локализованный строковый ресурс, на который могут ссылаться элементы NATVIS, принимающие строки (например, DisplayString, имя атрибута элемента "Item").
        Используйте формат "@&lt;id&gt;;", чтобы добавить ссылку на локализованную строку (например, @1001;)
      </xs:documentation>
    </xs:annotation>
    <xs:simpleContent>
      <xs:extension base="xs:string">
        <xs:attribute name="Id" use="required">
          <xs:annotation>
            <xs:documentation>Идентификатор локализованной строки. Чтобы сослаться на эту локализованную строку, используйте формат @&lt;id&gt;;.</xs:documentation>
          </xs:annotation>
          <xs:simpleType>
            <xs:restriction base="xs:unsignedInt">
              <xs:minInclusive value="1"/>
            </xs:restriction>
          </xs:simpleType>
        </xs:attribute>
      </xs:extension>
    </xs:simpleContent>
  </xs:complexType>

  <xs:complexType name="LocalizedStringsType">
    <xs:annotation>
      <xs:documentation>
        Указывает список локализованных строк, на которые могут ссылаться элементы NATVIS. Определите локализованные строки во вспомогательном NATVIS-файле, имя которого совпадает с именем основного фала,
        и разверните его в указанной локальной папке, рядом с основным NATVIS-файлом. Отладчик загрузит локализованные ресурсы и подходящего вспомогательного файла.
        Определите локализованные строки в основном NATVIS-файле , которые будут значениями по умолчанию, когда вспомогательный отсутствует в языковом стандарте.
      </xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element minOccurs="1" maxOccurs="unbounded" name="LocalizedString" type="LocalizedStringType"/>
    </xs:sequence>
  </xs:complexType>

  <!-- Definition of complex elements-->

  <xs:element name="AutoVisualizer">
    <xs:annotation>
      <xs:documentation>Корневой элемент NATVIS-файла.</xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:sequence>
        <xs:element minOccurs="0" maxOccurs="1" name="Version" type="VersionType">
          <xs:annotation>
            <xs:documentation>Указывает соответствующие имя и версию модуля для всех визуализаторов, которые не задают явным образом имя и версию модуля в этом файле.</xs:documentation>
          </xs:annotation>
        </xs:element>
        <xs:element minOccurs="0" maxOccurs="1" name="LocalizedStrings" type="LocalizedStringsType"/>
        <xs:element minOccurs="0" maxOccurs="unbounded" name="UIVisualizer" type="UIVisualizerType"/>
        <xs:choice minOccurs="0" maxOccurs="unbounded">
          <xs:element minOccurs="0" maxOccurs="unbounded" name="Type" type="VisualizerType"/>
          <xs:element minOccurs="0" maxOccurs="unbounded" name="HResult" type="HResultType"/>
          <xs:element minOccurs="0" maxOccurs="unbounded" name="Intrinsic" type="IntrinsicType"/>
        </xs:choice>
      </xs:sequence>
    </xs:complexType>
  </xs:element>
</xs:schema>
